"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeServer = void 0;
const http_1 = require("http");
const proxy_1 = require("./proxy");
const tunnel_1 = require("./tunnel");
const raw_body_1 = __importDefault(require("raw-body"));
const logger_1 = require("@applitools/logger");
const utils = __importStar(require("@applitools/utils"));
const RETRY_BACKOFF = [].concat(Array(5).fill(2000), // 5 tries with delay 2s (total 10s)
Array(4).fill(5000), // 4 tries with delay 5s (total 20s)
10000);
const RETRY_ERROR_CODES = ['CONCURRENCY_LIMIT_REACHED', 'NO_AVAILABLE_DRIVER_POD'];
function makeServer({ port = 0, forwardingUrl = 'https://exec-wus.applitools.com', tunnelUrl = process.env.APPLITOOLS_EG_TUNNEL_URL, serverUrl = process.env.APPLITOOLS_SERVER_URL, apiKey = process.env.APPLITOOLS_API_KEY, logger, } = {}) {
    logger = logger ? logger.extend({ label: 'eg-client' }) : (0, logger_1.makeLogger)({ label: 'eg-client', colors: true });
    const sessions = new Map();
    const { createTunnel, deleteTunnel } = (0, tunnel_1.makeTunnelManager)({ tunnelUrl, logger });
    const server = (0, http_1.createServer)(async (request, response) => {
        try {
            if (request.method === 'POST' && /^\/session\/?$/.test(request.url)) {
                return await handleNewSession(request, response);
            }
            else if (request.method === 'DELETE' && /^\/session\/[^\/]+\/?$/.test(request.url)) {
                return await handleStopSession(request, response);
            }
            else {
                return (0, proxy_1.proxy)(request, response, { target: forwardingUrl, forward: true });
            }
        }
        catch (err) {
            logger.error(`Error during processing request:`, err);
            response
                .writeHead(500)
                .end(JSON.stringify({ value: { error: 'internal proxy server error', message: err.message, stacktrace: '' } }));
        }
    });
    server.listen(port, 'localhost');
    return new Promise((resolve, reject) => {
        server.on('listening', () => {
            const address = server.address();
            logger.log(`Proxy server has started on port ${address.port}`);
            resolve({ url: `http://localhost:${address.port}`, port: address.port, server });
        });
        server.on('error', async (err) => {
            logger.fatal('Error starting proxy server', err);
            reject(err);
        });
    });
    async function handleNewSession(request, response) {
        var _a, _b, _c, _d, _e, _f, _g;
        const session = {};
        const requestLogger = logger.extend({
            tags: { signature: `[${request.method}]${request.url}`, requestId: utils.general.guid() },
        });
        const requestBody = await (0, raw_body_1.default)(request, 'utf-8').then(body => (body ? JSON.parse(body) : undefined));
        if (!requestBody)
            return requestLogger.log(`Request has no body`);
        requestLogger.log(`Request was intercepted with body:`, requestBody);
        const capabilities = (_b = (_a = requestBody.capabilities) === null || _a === void 0 ? void 0 : _a.alwaysMatch) !== null && _b !== void 0 ? _b : requestBody.desiredCapabilities;
        session.serverUrl = capabilities['applitools:eyesServerUrl'] = (_c = capabilities['applitools:eyesServerUrl']) !== null && _c !== void 0 ? _c : serverUrl;
        session.apiKey = capabilities['applitools:apiKey'] = (_d = capabilities['applitools:apiKey']) !== null && _d !== void 0 ? _d : apiKey;
        if (capabilities['applitools:tunnel']) {
            session.tunnelId = capabilities['applitools:x-tunnel-id-0'] = await createTunnel(session);
        }
        requestLogger.log('Request body has modified:', requestBody);
        let attempt = 0;
        while (true) {
            const proxyResponse = await (0, proxy_1.proxy)(request, response, { target: forwardingUrl, body: requestBody });
            const responseBody = await (0, raw_body_1.default)(proxyResponse, 'utf-8').then(body => (body ? JSON.parse(body) : undefined));
            if (!responseBody) {
                response.writeHead(proxyResponse.statusCode, proxyResponse.headers).end();
                return requestLogger.log(`Response has no body`);
            }
            requestLogger.log(`Response was intercepted with body:`, responseBody);
            if (!RETRY_ERROR_CODES.includes((_f = (_e = responseBody.value) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.appliErrorCode)) {
                if ((_g = responseBody.value) === null || _g === void 0 ? void 0 : _g.sessionId)
                    sessions.set(responseBody.value.sessionId, session);
                response.writeHead(proxyResponse.statusCode, proxyResponse.headers).end(JSON.stringify(responseBody));
                return;
            }
            await utils.general.sleep(RETRY_BACKOFF[Math.min(attempt, RETRY_BACKOFF.length - 1)]);
            attempt += 1;
            request.removeAllListeners();
            requestLogger.log(`Retrying sending the request (attempt ${attempt})`);
        }
    }
    async function handleStopSession(request, response) {
        const requestLogger = logger.extend({
            tags: { signature: `[${request.method}]${request.url}`, requestId: utils.general.guid() },
        });
        const sessionId = request.url.split('/').pop();
        requestLogger.log(`Request was intercepted with sessionId:`, sessionId);
        const proxyResponse = await (0, proxy_1.proxy)(request, response, { target: forwardingUrl });
        const session = sessions.get(sessionId);
        if (session.tunnelId) {
            await deleteTunnel(session);
            requestLogger.log(`Tunnel with id ${session.tunnelId} was deleted for session with id ${sessionId}`);
        }
        sessions.delete(sessionId);
        proxyResponse.pipe(response.writeHead(proxyResponse.statusCode, proxyResponse.headers));
    }
}
exports.makeServer = makeServer;
